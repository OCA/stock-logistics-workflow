-
  !context
    uid: 'res_users_emma'
-
  I update the available quantity for the product "iMac"
-
  !record {model: stock.change.product.qty, id: change_qty_1}:
    new_quantity: 15
    product_id: product.product_product_8
-
  !python {model: stock.change.product.qty}: |
    self.change_product_qty(cr, uid, [ref('change_qty_1')], context=dict(
        context, active_id=ref('product.product_product_8')))
-
  I create three incoming pickings for the same product. They could be
  generated by the Purchase Orders PO1, PO2, and PO3. We do not handle the
  orders here, except for the origin field.
-
  !record {model: stock.picking, id: picking_in_1}:
    picking_type_id: stock.picking_type_in
-
  !record {model: stock.move, id: move_in_1}:
    picking_id: picking_in_1
    origin: PO1
    product_uom_qty: 10
    product_uom: product.product_uom_unit
    name: line1 in
    product_id: product.product_product_8
    location_id: stock.stock_location_suppliers
    location_dest_id: stock.stock_location_stock
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_in_1'), {
        'date_expected': '{0}-12-10'.format(datetime.date.today().year + 1)
    })
-
  !record {model: stock.picking, id: picking_in_2}:
    picking_type_id: stock.picking_type_in
-
  !record {model: stock.move, id: move_in_2}:
    picking_id: picking_in_2
    origin: PO2
    product_uom_qty: 30
    product_uom: product.product_uom_unit
    name: line2 in
    product_id: product.product_product_8
    location_id: stock.stock_location_suppliers
    location_dest_id: stock.stock_location_stock
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_in_2'), {
        'date_expected': '{0}-12-20'.format(datetime.date.today().year + 1)
    })
-
  !record {model: stock.picking, id: picking_in_3}:
    picking_type_id: stock.picking_type_in
-
  !record {model: stock.move, id: move_in_3}:
    picking_id: picking_in_3
    origin: PO3
    product_uom_qty: 30
    product_uom: product.product_uom_unit
    name: line3 in
    product_id: product.product_product_8
    location_id: stock.stock_location_suppliers
    location_dest_id: stock.stock_location_stock
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_in_3'), {
        'date_expected': '{0}-12-29'.format(datetime.date.today().year + 1)
    })
-
  !python {model: stock.picking, id: picking_in_1}: |
    self.action_assign()
-
  !python {model: stock.picking, id: picking_in_2}: |
    self.action_assign()
-
  !python {model: stock.picking, id: picking_in_3}: |
    self.action_assign()
-
  I create three outgoing pickings for the same product. They could be
  generated by the Sale Orders SO1, SO2, and SO3. We do not handle the
  orders here, except for the origin field.
-
  !record {model: stock.picking, id: picking_out_1}:
    picking_type_id: stock.picking_type_out
-
  !record {model: stock.move, id: move_out_1}:
    picking_id: picking_out_1
    origin: SO1
    product_uom_qty: 15
    product_uom: product.product_uom_unit
    name: line1 out
    product_id: product.product_product_8
    location_id: stock.stock_location_stock
    location_dest_id: stock.stock_location_customers
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_out_1'), {
        'date': '{0}-12-03'.format(datetime.date.today().year + 1)
    })
-
  !record {model: stock.picking, id: picking_out_2}:
    picking_type_id: stock.picking_type_out
-
  !record {model: stock.move, id: move_out_2}:
    picking_id: picking_out_2
    origin: SO2
    product_uom_qty: 10
    product_uom: product.product_uom_unit
    name: line2 out
    product_id: product.product_product_8
    location_id: stock.stock_location_stock
    location_dest_id: stock.stock_location_customers
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_out_2'), {
        'date': '{0}-12-01'.format(datetime.date.today().year + 1)
    })
-
  !record {model: stock.picking, id: picking_out_3}:
    picking_type_id: stock.picking_type_out
-
  !record {model: stock.move, id: move_out_3}:
    picking_id: picking_out_3
    origin: SO3
    product_uom_qty: 50
    product_uom: product.product_uom_unit
    name: line3 out
    product_id: product.product_product_8
    location_id: stock.stock_location_stock
    location_dest_id: stock.stock_location_customers
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_out_3'), {
        'date': '{0}-12-05'.format(datetime.date.today().year + 1)
    })
-
  !python {model: stock.picking, id: picking_out_1}: |
    self.action_assign()
-
  !python {model: stock.picking, id: picking_out_2}: |
    self.action_assign()
-
  !python {model: stock.picking, id: picking_out_3}: |
    self.action_assign()
-
  I compute the delivery dates with the existing cursor, because a new cursor
  would isolate us from test data created in the main transaction, like the
  user itself.
-
 !python {model: stock.picking}: |
   self.compute_all_delivery_dates(cr, uid, use_new_cursor=False,
                                   context=context)
-
  !python {model: stock.move}: |
    import datetime as dt
    from openerp.tools import DEFAULT_SERVER_DATE_FORMAT as DATE_FORMAT
    security_days = dt.timedelta(days=2)

    move_out_1 = model.browse(cr, uid, ref('move_out_1'), context)
    actual_date = move_out_1.date_expected[:10]
    wanted_date = '{0}-12-12'.format(dt.date.today().year + 1)
    assert actual_date == wanted_date, (
        'move_out_1 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )

    move_out_2 = model.browse(cr, uid, ref('move_out_2'), context)
    actual_date = move_out_2.date_expected[:10]
    wanted_date = dt.date.strftime(dt.date.today() + security_days, DATE_FORMAT)
    assert actual_date == wanted_date, (
        'move_out_2 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )

    move_out_3 = model.browse(cr, uid, ref('move_out_3'), context)
    actual_date = move_out_3.date_expected[:10]
    wanted_date = '{0}-12-31'.format(dt.date.today().year + 1)
    assert actual_date == wanted_date, (
        'move_out_3 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )
-
 I compute the delivery dates again. Nothing should change.
-
 !python {model: stock.picking}: |
   self.compute_all_delivery_dates(cr, uid, use_new_cursor=False,
                                   context=context)
-
  !python {model: stock.move}: |
    import datetime as dt
    from openerp.tools import DEFAULT_SERVER_DATE_FORMAT as DATE_FORMAT
    security_days = dt.timedelta(days=2)

    move_out_1 = model.browse(cr, uid, ref('move_out_1'), context)
    actual_date = move_out_1.date_expected[:10]
    wanted_date = '{0}-12-12'.format(dt.date.today().year + 1)
    assert actual_date == wanted_date, (
        'move_out_1 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )

    move_out_2 = model.browse(cr, uid, ref('move_out_2'), context)
    actual_date = move_out_2.date_expected[:10]
    wanted_date = dt.date.strftime(dt.date.today() + security_days, DATE_FORMAT)
    assert actual_date == wanted_date, (
        'move_out_2 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )

    move_out_3 = model.browse(cr, uid, ref('move_out_3'), context)
    actual_date = move_out_3.date_expected[:10]
    wanted_date = '{0}-12-31'.format(dt.date.today().year + 1)
    assert actual_date == wanted_date, (
        'move_out_3 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )
