-
  !python {model: res.company, id: base.main_company}: |
    self.security_lead = 2.0
-
  !context
    uid: 'res_users_emma'
-
  I update the available quantity for the product "Ink Cartridge"
-
  !record {model: stock.change.product.qty, id: change_qty_2}:
    new_quantity: 15
    product_id: product.product_product_26
-
  !python {model: stock.change.product.qty}: |
    self.change_product_qty(cr, uid, [ref('change_qty_2')], context=dict(
        context, active_id=ref('product.product_product_26')))
-
  I create three incoming pickings for the same product. They could be
  generated by the Purchase Orders PO1, PO2, and PO3. We do not handle the
  orders here, except for the origin field.
-
  !record {model: stock.picking, id: picking_in_4}:
    picking_type_id: stock.picking_type_in
-
  !record {model: stock.move, id: move_in_4}:
    picking_id: picking_in_4
    origin: PO1
    product_uom_qty: 15
    product_uom: product.product_uom_unit
    name: line4 in
    product_id: product.product_product_26
    location_id: stock.stock_location_suppliers
    location_dest_id: stock.stock_location_stock
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_in_4'), {
        'date_expected': '{0}-12-10'.format(datetime.date.today().year + 1)
    })
-
  !record {model: stock.picking, id: picking_in_5}:
    picking_type_id: stock.picking_type_in
-
  !record {model: stock.move, id: move_in_5}:
    picking_id: picking_in_5
    origin: PO2
    product_uom_qty: 30
    product_uom: product.product_uom_unit
    name: line5 in
    product_id: product.product_product_26
    location_id: stock.stock_location_suppliers
    location_dest_id: stock.stock_location_stock
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_in_5'), {
        'date_expected': '{0}-12-20'.format(datetime.date.today().year + 1)
    })
-
  !record {model: stock.picking, id: picking_in_6}:
    picking_type_id: stock.picking_type_in
-
  !record {model: stock.move, id: move_in_6}:
    picking_id: picking_in_6
    origin: PO3
    product_uom_qty: 30
    product_uom: product.product_uom_unit
    name: line6 in
    product_id: product.product_product_26
    location_id: stock.stock_location_suppliers
    location_dest_id: stock.stock_location_stock
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_in_6'), {
        'date_expected': '{0}-12-29'.format(datetime.date.today().year + 1)
    })
-
  !python {model: stock.picking, id: picking_in_4}: |
    self.action_assign()
-
  !python {model: stock.picking, id: picking_in_5}: |
    self.action_assign()
-
  !python {model: stock.picking, id: picking_in_6}: |
    self.action_assign()
-
  I create three outgoing pickings for the same product. They could be
  generated by the Sale Orders SO1, SO2, and SO3. We do not handle the
  orders here, except for the origin field.
-
  !record {model: stock.picking, id: picking_out_4}:
    picking_type_id: stock.picking_type_out
-
  !record {model: stock.move, id: move_out_4}:
    picking_id: picking_out_4
    origin: SO1
    product_uom_qty: 15
    product_uom: product.product_uom_unit
    name: line4 out
    product_id: product.product_product_26
    location_id: stock.stock_location_stock
    location_dest_id: stock.stock_location_customers
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_out_4'), {
        'date': '{0}-12-03'.format(datetime.date.today().year + 1)
    })
-
  !record {model: stock.picking, id: picking_out_5}:
    picking_type_id: stock.picking_type_out
-
  !record {model: stock.move, id: move_out_5}:
    picking_id: picking_out_5
    origin: SO2
    product_uom_qty: 10
    product_uom: product.product_uom_unit
    name: line5 out
    product_id: product.product_product_26
    location_id: stock.stock_location_stock
    location_dest_id: stock.stock_location_customers
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_out_5'), {
        'date': '{0}-12-05'.format(datetime.date.today().year + 1)
    })
-
  !record {model: stock.picking, id: picking_out_6}:
    picking_type_id: stock.picking_type_out
-
  !record {model: stock.move, id: move_out_6}:
    picking_id: picking_out_6
    origin: SO3
    product_uom_qty: 50
    product_uom: product.product_uom_unit
    name: line6 out
    product_id: product.product_product_26
    location_id: stock.stock_location_stock
    location_dest_id: stock.stock_location_customers
-
  !python {model: stock.move}: |
    import datetime
    self.write(cr, uid, ref('move_out_6'), {
        'date': '{0}-12-01'.format(datetime.date.today().year + 1)
    })
-
  !python {model: stock.picking, id: picking_out_4}: |
    self.action_assign()
-
  !python {model: stock.picking, id: picking_out_5}: |
    self.action_assign()
-
  !python {model: stock.picking, id: picking_out_6}: |
    self.action_assign()
-
  I compute the delivery dates with the global wizard
-
  !record {model: compute.delivery.date.by.product.wizard, id: product_wizard_1}:
-
  !python {model: compute.delivery.date.by.product.wizard}: |
    self.do_compute(cr, uid, [ref('product_wizard_1')], {'active_ids': [ref('product.product_product_26')]})
-
  !python {model: stock.move}: |
    import datetime as dt
    from openerp.tools import DEFAULT_SERVER_DATE_FORMAT as DATE_FORMAT
    security_days = dt.timedelta(days=2)

    move_out_4 = model.browse(cr, uid, ref('move_out_4'), context)
    actual_date = move_out_4.date_expected[:10]
    wanted_date = '{0}-12-31'.format(dt.date.today().year + 1)
    assert actual_date == wanted_date, (
        'move_out_4 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )

    move_out_5 = model.browse(cr, uid, ref('move_out_5'), context)
    actual_date = move_out_5.date_expected[:10]
    wanted_date = '{0}-12-31'.format(dt.date.today().year + 1)
    assert actual_date == wanted_date, (
        'move_out_5 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )

    move_out_6 = model.browse(cr, uid, ref('move_out_6'), context)
    actual_date = move_out_6.date_expected[:10]
    wanted_date = '{0}-12-22'.format(dt.date.today().year + 1)
    assert actual_date == wanted_date, (
        'move_out_6 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )
-
  I compute the delivery dates again. Nothing should change.
-
  !record {model: compute.delivery.date.by.product.wizard, id: product_wizard_1z}:
-
  !python {model: compute.delivery.date.by.product.wizard}: |
    self.do_compute(cr, uid, [ref('product_wizard_1z')], {'active_ids': [ref('product.product_product_26')]})
-
  !python {model: stock.move}: |
    import datetime as dt
    from openerp.tools import DEFAULT_SERVER_DATE_FORMAT as DATE_FORMAT
    security_days = dt.timedelta(days=2)

    move_out_4 = model.browse(cr, uid, ref('move_out_4'), context)
    actual_date = move_out_4.date_expected[:10]
    wanted_date = '{0}-12-31'.format(dt.date.today().year + 1)
    assert actual_date == wanted_date, (
        'move_out_4 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )

    move_out_5 = model.browse(cr, uid, ref('move_out_5'), context)
    actual_date = move_out_5.date_expected[:10]
    wanted_date = '{0}-12-31'.format(dt.date.today().year + 1)
    assert actual_date == wanted_date, (
        'move_out_5 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )

    move_out_6 = model.browse(cr, uid, ref('move_out_6'), context)
    actual_date = move_out_6.date_expected[:10]
    wanted_date = '{0}-12-22'.format(dt.date.today().year + 1)
    assert actual_date == wanted_date, (
        'move_out_6 should be delivered on {0}, not on {1}'.format(
            wanted_date,
            actual_date,
        )
    )
